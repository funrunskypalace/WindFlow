/******************************************************************************
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 *  License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 ******************************************************************************
 */

/** 
 *  @file    builders.hpp
 *  @author  Gabriele Mencagli
 *  @date    06/09/2018
 *  
 *  @brief Builders used to create WindFlow operators
 *  
 *  @section Builders-1 (Description)
 *  
 *  Set of builders used to create WindFlow operators.
 */ 

#ifndef BUILDERS_H
#define BUILDERS_H

/// includes
#include<chrono>
#include<memory>
#include<functional>
#include<meta.hpp>
#include<basic.hpp>

namespace wf {

/** 
 *  \class Source_Builder
 *  
 *  \brief Builder of the Source operator
 *  
 *  Builder class to ease the creation of the Source operator.
 */ 
template<typename F_t>
class Source_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_result_t_Source(func));
    // static assert to check the signature
    static_assert(!std::is_same<tuple_t, std::false_type>::value,
        "WindFlow Compilation Error - unknown signature passed to the Source_Builder:\n"
        "  Candidate 1 : bool(tuple_t &)\n"
        "  Candidate 2 : bool(tuple_t &, RuntimeContext &)\n"
        "  Candidate 3 : bool(Shipper<tuple_t> &)\n"
        "  Candidate 4 : bool(Shipper<tuple_t> &, RuntimeContext &)\n");
    using source_t = Source<tuple_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t pardegree = 1;
    std::string name = "source";
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic to generate the stream elements
     */ 
    Source_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the Source operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    Source_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Source operator
     *  
     *  \param _pardegree number of source replicas
     *  \return the object itself
     */ 
    Source_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    Source_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Source):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Source operator (only C++17)
     *  
     *  \return a copy of the created Source operator
     */ 
    source_t build()
    {
        return source_t(func, 
                        pardegree,
                        name,
                        closing_func); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Source operator
     *  
     *  \return a pointer to the created Source operator (to be explicitly deallocated/destroyed)
     */ 
    source_t *build_ptr()
    {
        return new source_t(func,
                            pardegree,
                            name,
                            closing_func);
    }

    /** 
     *  \brief Method to create the Source operator
     *  
     *  \return a unique_ptr to the created Source operator
     */ 
    std::unique_ptr<source_t> build_unique()
    {
        return std::make_unique<source_t>(func,
                                          pardegree,
                                          name,
                                          closing_func);
    }
};

/** 
 *  \class Filter_Builder
 *  
 *  \brief Builder of the Filter operator
 *  
 *  Builder class to ease the creation of the Filter operator.
 */ 
template<typename F_t>
class Filter_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Filter(func));
    using result_t = decltype(get_result_t_Filter(func));
    // static assert to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the Filter_Builder:\n"
        "  Candidate 1 : bool(tuple_t &)\n"
        "  Candidate 2 : bool(tuple_t &, RuntimeContext &)\n"
        "  Candidate 3 : std::optional<result_t>(const tuple_t &)\n"
        "  Candidate 4 : std::optional<result_t>(const tuple_t &, RuntimeContext &)\n"
        "  Candidate 5 : std::optional<result_t *>(const tuple_t &)\n"
        "  Candidate 6 : std::optional<result_t *>(const tuple_t &, RuntimeContext &)\n");
    using filter_t = Filter<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t pardegree = 1;
    std::string name = "filter";
    bool isKeyBy = false;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic implementing the predicate
     */ 
    Filter_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the Filter operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    Filter_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Filter operator
     *  
     *  \param _pardegree number of filter replicas
     *  \return the object itself
     */ 
    Filter_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to enable the key-based routing
     *  
     *  \return the object itself
     */ 
    Filter_Builder<F_t> &enable_KeyBy()
    {
        isKeyBy = true;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    Filter_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Filter):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Filter operator (only C++17)
     *  
     *  \return a copy of the created Map operator
     */ 
    filter_t build()
    {
        if (!isKeyBy) {
            return filter_t(func,
                            pardegree,
                            name,
                            closing_func); // guaranteed copy elision in C++17
        }
        else {
            return filter_t(func,
                            pardegree,
                            name,
                            closing_func,
                            routing_func); // guaranteed copy elision in C++17
        }
    }
#endif

    /** 
     *  \brief Method to create the Filter operator
     *  
     *  \return a pointer to the created Filter operator (to be explicitly deallocated/destroyed)
     */ 
    filter_t *build_ptr()
    {
        if (!isKeyBy) {
            return new filter_t(func,
                                pardegree,
                                name,
                                closing_func);
        }
        else {
            return new filter_t(func,
                                pardegree,
                                name,
                                closing_func,
                                routing_func);
        }
    }

    /** 
     *  \brief Method to create the Filter operator
     *  
     *  \return a unique_ptr to the created Filter operator
     */ 
    std::unique_ptr<filter_t> build_unique()
    {
        if (!isKeyBy) {
            return std::make_unique<filter_t>(func,
                                              pardegree,
                                              name,
                                              closing_func);
        }
        else {
            return std::make_unique<filter_t>(func,
                                              pardegree,
                                              name,
                                              closing_func,
                                              routing_func);
        }
    }
};

/** 
 *  \class Map_Builder
 *  
 *  \brief Builder of the Map operator
 *  
 *  Builder class to ease the creation of the Map operator.
 */ 
template<typename F_t>
class Map_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Map(func));
    using result_t = decltype(get_result_t_Map(func));
    // static assert to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the Map_Builder:\n"
        "  Candidate 1 : void(tuple_t &)\n"
        "  Candidate 2 : void(tuple_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(const tuple_t &, result_t &, RuntimeContext &)\n");
    using map_t = Map<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t pardegree = 1;
    std::string name = "map";
    bool isKeyBy = false;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic implementing the one-to-one transformation
     */ 
    Map_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the Map operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    Map_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Map operator
     *  
     *  \param _pardegree number of map replicas
     *  \return the object itself
     */ 
    Map_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to enable the key-based routing
     *  
     *  \return the object itself
     */ 
    Map_Builder<F_t> &enable_KeyBy()
    {
        isKeyBy = true;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    Map_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Map):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Map operator (only C++17)
     *  
     *  \return a copy of the created Map operator
     */ 
    map_t build()
    {
        if (!isKeyBy) {
            return map_t(func,
                         pardegree,
                         name,
                         closing_func); // guaranteed copy elision in C++17
        }
        else {
            return map_t(func,
                         pardegree,
                         name,
                         closing_func,
                         routing_func); // guaranteed copy elision in C++17
        }
    }
#endif

    /** 
     *  \brief Method to create the Map operator
     *  
     *  \return a pointer to the created Map operator (to be explicitly deallocated/destroyed)
     */ 
    map_t *build_ptr()
    {
        if (!isKeyBy) {
            return new map_t(func,
                             pardegree,
                             name,
                             closing_func);
        }
        else {
            return new map_t(func,
                             pardegree,
                             name,
                             closing_func,
                             routing_func);
        }
    }

    /** 
     *  \brief Method to create the Map operator
     *  
     *  \return a unique_ptr to the created Map operator
     */ 
    std::unique_ptr<map_t> build_unique()
    {
        if (!isKeyBy) {
            return std::make_unique<map_t>(func,
                                           pardegree,
                                           name,
                                           closing_func);
        }
        else {
            return std::make_unique<map_t>(func,
                                           pardegree,
                                           name,
                                           closing_func,
                                           routing_func);
        }
    }
};

/** 
 *  \class FlatMap_Builder
 *  
 *  \brief Builder of the FlatMap operator
 *  
 *  Builder class to ease the creation of the FlatMap operator.
 */ 
template<typename F_t>
class FlatMap_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_FlatMap(func));
    using result_t = decltype(get_result_t_FlatMap(func));
    // static assert to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the FlatMap_Builder:\n"
        "  Candidate 1 : void(const tuple_t &, Shipper<result_t> &)\n"
        "  Candidate 2 : void(const tuple_t &, Shipper<result_t> &, RuntimeContext &)\n");
    using flatmap_t = FlatMap<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t pardegree = 1;
    std::string name = "flatmap";
    bool isKeyBy = false;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic implementing the one-to-any transformation
     */ 
    FlatMap_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the FlatMap operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    FlatMap_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the FlatMap operator
     *  
     *  \param _pardegree number of flatmap replicas
     *  \return the object itself
     */ 
    FlatMap_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to enable the key-based routing
     *  
     *  \return the object itself
     */ 
    FlatMap_Builder<F_t> &enable_KeyBy()
    {
        isKeyBy = true;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    FlatMap_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a FlatMap):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the FlatMap operator (only C++17)
     *  
     *  \return a copy of the created FlatMap operator
     */ 
    flatmap_t build()
    {
        if (!isKeyBy) {
            return flatmap_t(func,
                             pardegree,
                             name,
                             closing_func); // guaranteed copy elision in C++17
        }
        else {
            return flatmap_t(func,
                             pardegree,
                             name,
                             closing_func,
                             routing_func); // guaranteed copy elision in C++17
        }
    }
#endif

    /** 
     *  \brief Method to create the FlatMap operator
     *  
     *  \return a pointer to the created FlatMap operator (to be explicitly deallocated/destroyed)
     */ 
    flatmap_t *build_ptr()
    {
        if (!isKeyBy) {
            return new flatmap_t(func,
                                 pardegree,
                                 name,
                                 closing_func);
        }
        else {
            return new flatmap_t(func,
                                 pardegree,
                                 name,
                                 closing_func,
                                 routing_func);
        }
    }

    /** 
     *  \brief Method to create the FlatMap operator
     *  
     *  \return a unique_ptr to the created FlatMap operator
     */ 
    std::unique_ptr<flatmap_t> build_unique()
    {
        if (!isKeyBy) {
            return std::make_unique<flatmap_t>(func,
                                               pardegree,
                                               name,
                                               closing_func);
        }
        else {
            return std::make_unique<flatmap_t>(func,
                                               pardegree,
                                               name,
                                               closing_func,
                                               routing_func);
        }
    }
};

/** 
 *  \class Accumulator_Builder
 *  
 *  \brief Builder of the Accumulator operator
 *  
 *  Builder class to ease the creation of the Accumulator operator.
 */ 
template<typename F_t>
class Accumulator_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Acc(func));
    using result_t = decltype(get_result_t_Acc(func));
    // static assert to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the Accumulator_Builder:\n"
        "  Candidate 1 : void(const tuple_t &, result_t &)\n"
        "  Candidate 2 : void(const tuple_t &, result_t &, RuntimeContext &)\n");
    using accumulator_t = Accumulator<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t pardegree = 1;
    std::string name = "accumulator";
    result_t init_value;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic implementing the reduce/fold logic
     */ 
    Accumulator_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the Accumulator operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    Accumulator_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the initial value for the fold logic
     *         (for the reduce the initial value is the one obtained by the
     *          default Constructor of result_t)
     *  
     *  \param _init_value initial value
     *  \return the object itself
     */ 
    Accumulator_Builder<F_t> &withInitialValue(result_t _init_value)
    {
        init_value = _init_value;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Accumulator operator
     *  
     *  \param _pardegree number of accumulator replicas
     *  \return the object itself
     */ 
    Accumulator_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    Accumulator_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of an Accumulator):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Accumulator operator (only C++17)
     *  
     *  \return a copy of the created Accumulator operator
     */ 
    accumulator_t build()
    {
        return accumulator_t(func,
                             init_value,
                             pardegree,
                             name,
                             closing_func,
                             routing_func); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Accumulator operator
     *  
     *  \return a pointer to the created Accumulator operator (to be explicitly deallocated/destroyed)
     */ 
    accumulator_t *build_ptr()
    {
        return new accumulator_t(func,
                                 init_value,
                                 pardegree,
                                 name,
                                 closing_func,
                                 routing_func);
    }

    /** 
     *  \brief Method to create the Accumulator operator
     *  
     *  \return a unique_ptr to the created Accumulator operator
     */ 
    std::unique_ptr<accumulator_t> build_unique()
    {
        return std::make_unique<accumulator_t>(func,
                                               init_value,
                                               pardegree,
                                               name,
                                               closing_func,
                                               routing_func);
    }
};

/** 
 *  \class WinSeq_Builder
 *  
 *  \brief Builder of the Win_Seq node
 *  
 *  Builder class to ease the creation of the Win_Seq node.
 */ 
template<typename F_t>
class WinSeq_Builder
{
private:
    F_t func;
    // extract the type of the node to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Win(func));
    using result_t = decltype(get_result_t_Win(func));
    // static assert to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the WinSeq_Builder:\n"
        "  Candidate 1 : void(uint64_t, const Iterable<tuple_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<tuple_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const tuple_t &, result_t &, RuntimeContext &)\n");
    using winseq_t = Win_Seq<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    std::string name = "seq";
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic implementing the non-incremental/incremental window processing
     */ 
    WinSeq_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    WinSeq_Builder<F_t> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    WinSeq_Builder<F_t> &withTBWindows(std::chrono::microseconds _win_len,
                                       std::chrono::microseconds _slide_len,
                                       std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Win_Seq node
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    WinSeq_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the node
     *  
     *  \param _closing_func closing logic to be used by the node
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    WinSeq_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Win_Seq):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Win_Seq node (only C++17)
     *  
     *  \return a copy of the created Win_Seq node
     */ 
    winseq_t build()
    {
        return winseq_t(func,
                        win_len,
                        slide_len,
                        triggering_delay,
                        winType, name,
                        closing_func,
                        RuntimeContext(1, 0),
                        WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len),
                        role_t::SEQ); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Win_Seq node
     *  
     *  \return a pointer to the created Win_Seq node (to be explicitly deallocated/destroyed)
     */ 
    winseq_t *build_ptr()
    {
        return new winseq_t(func, win_len,
                            slide_len,
                            triggering_delay,
                            winType,
                            name,
                            closing_func,
                            RuntimeContext(1, 0),
                            WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len),
                            role_t::SEQ);
    }

    /** 
     *  \brief Method to create the Win_Seq node
     *  
     *  \return a unique_ptr to the created Win_Seq node
     */ 
    std::unique_ptr<winseq_t> build_unique()
    {
        return std::make_unique<winseq_t>(func,
                                          win_len,
                                          slide_len,
                                          triggering_delay,
                                          winType,
                                          name,
                                          closing_func,
                                          RuntimeContext(1, 0),
                                          WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len),
                                          role_t::SEQ);
    }
};

/** 
 *  \class WinSeqFFAT_Builder
 *  
 *  \brief Builder of the Win_SeqFFAT node
 *  
 *  Builder class to ease the creation of the Win_SeqFFAT node.
 */ 
template<typename F_t, typename G_t>
class WinSeqFFAT_Builder
{
private:
    F_t lift_func;
    G_t comb_func;
    // extract the type of the node to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Lift(lift_func));
    using result_t = decltype(get_result_t_Lift(lift_func));
    // static asserts to check the signatures
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the WinSeqFFAT_Builder (first argument, lift logic):\n"
        "  Candidate 1 : void(const tuple_t &, result_t &)\n"
        "  Candidate 2 : void(const tuple_t &, result_t &, RuntimeContext &)\n");
    using result_t2 = decltype(get_result_t_Comb(comb_func));
    static_assert(!(std::is_same<std::false_type, result_t2>::value),
        "WindFlow Compilation Error - unknown signature passed to the WinSeqFFAT_Builder (second argument, combine logic):\n"
        "  Candidate 1 : void(const result_t &, const result_t &, result_t &)\n"
        "  Candidate 2 : void(const result_t &, const result_t &, result_t &, RuntimeContext &)\n");
    static_assert(std::is_same<result_t, result_t2>::value,
        "WindFlow Compilation Error - type mismatch in the WinSeqFFAT_Builder (output type of the lift logic must be equal to the input type of the combine logic)\n");
    using winffat_t = Win_SeqFFAT<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    std::string name = "seqffat";
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _lift_func the lift logic to translate a tuple into a result
     *  \param _comb_func the combine logic to combine two results into a result
     */ 
    WinSeqFFAT_Builder(F_t _lift_func, G_t _comb_func): lift_func(_lift_func), comb_func(_comb_func) {}

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    WinSeqFFAT_Builder<F_t, G_t> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    WinSeqFFAT_Builder<F_t, G_t> &withTBWindows(std::chrono::microseconds _win_len,
                                                std::chrono::microseconds _slide_len,
                                                std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Win_SeqFFAT node
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    WinSeqFFAT_Builder<F_t, G_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the node
     *  
     *  \param _closing_func closing logic to be used by the node
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    WinSeqFFAT_Builder<F_t, G_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Win_SeqFFAT):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Win_SeqFFAT node (only C++17)
     *  
     *  \return a copy of the created Win_SeqFFAT node
     */ 
    winffat_t build()
    {
        return winffat_t(lift_func,
                         comb_func,
                         win_len,
                         slide_len,
                         triggering_delay,
                         winType,
                         name,
                         closing_func,
                         RuntimeContext(1, 0),
                         WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len));
    }
#endif

    /** 
     *  \brief Method to create the Win_SeqFFAT node
     *  
     *  \return a pointer to the created Win_SeqFFAT node (to be explicitly deallocated/destroyed)
     */ 
    winffat_t *build_ptr()
    {
        return new winffat_t(lift_func,
                             comb_func,
                             win_len,
                             slide_len,
                             triggering_delay,
                             winType,
                             name,
                             closing_func,
                             RuntimeContext(1, 0),
                             WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len));
    }

    /** 
     *  \brief Method to create the Win_SeqFFAT node
     *  
     *  \return a unique_ptr to the created Win_SeqFFAT node
     */ 
    std::unique_ptr<winffat_t> build_unique()
    {
        return std::make_unique<winffat_t>(lift_func,
                                           comb_func,
                                           win_len,
                                           slide_len,
                                           triggering_delay,
                                           winType,
                                           name,
                                           closing_func,
                                           RuntimeContext(1, 0),
                                           WinOperatorConfig(0, 1, slide_len, 0, 1, slide_len));
    }
};

/** 
 *  \class WinFarm_Builder
 *  
 *  \brief Builder of the Win_Farm operator
 *  
 *  Builder class to ease the creation of the Win_Farm operator.
 */ 
template<typename T>
class WinFarm_Builder
{
private:
    T &input;
    // extract the type of the operator to be generated by this builder (with static checks)
    using winfarm_t = std::remove_reference_t<decltype(*get_WF_nested_type(input))>;
    // static assert to check the signature
    static_assert(!std::is_same<winfarm_t, std::false_type>::value,
        "WindFlow Compilation Error - unknown signature passed to the WinFarm_Builder:\n"
        "  Candidate 1 : void(uint64_t, const Iterable<tuple_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<tuple_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const tuple_t &, result_t &, RuntimeContext &)\n"
        "  Candidate 5 : a valid Pane_Farm operator\n"
        "  Candidate 6 : a valid Win_MapReduce operator\n");
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    size_t pardegree = 1;
    std::string name = "wf";
    opt_level_t opt_level = opt_level_t::LEVEL2;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

    // window parameters initialization (input is a Pane_Farm)
    template<typename ...Args>
    void initWindowConf(Pane_Farm<Args...> &_pf)
    {
        win_len = _pf.win_len;
        slide_len = _pf.slide_len;
        triggering_delay = _pf.triggering_delay;
        winType = _pf.winType;
    }

    // window parameters initialization (input is a Win_MapReduce)
    template<typename ...Args>
    void initWindowConf(Win_MapReduce<Args...> &_wmr)
    {
        win_len = _wmr.win_len;
        slide_len = _wmr.slide_len;
        triggering_delay = _wmr.triggering_delay;
        winType = _wmr.winType;
    }

    // window parameters initialization (input is a logic)
    template<typename T2>
    void initWindowConf(T2 &f)
    {
        win_len = 1;
        slide_len = 1;
        triggering_delay = 0;
        winType = win_type_t::CB;
    }

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _input can be either a non-incremental/incremental window processing logic or an
     *                already instantiated Pane_Farm or Win_MapReduce operator.
     */ 
    WinFarm_Builder(T &_input): input(_input)
    {
        initWindowConf(input);
    }

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    WinFarm_Builder<T> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    WinFarm_Builder<T> &withTBWindows(std::chrono::microseconds _win_len,
                                      std::chrono::microseconds _slide_len,
                                      std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Win_Farm operator
     *  
     *  \param _pardegree number of replicas
     *  \return the object itself
     */ 
    WinFarm_Builder<T> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Win_Farm operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    WinFarm_Builder<T> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the optimization level to build the Win_Farm operator
     *  
     *  \param _opt_level (optimization level)
     *  \return the object itself
     */ 
    WinFarm_Builder<T> &withOptLevel(opt_level_t _opt_level)
    {
        opt_level = _opt_level;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    WinFarm_Builder<T> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Win_Farm):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Win_Farm operator (only C++17)
     *  
     *  \return a copy of the created Win_Farm operator
     */ 
    winfarm_t build()
    {
        return winfarm_t(input,
                         win_len,
                         slide_len,
                         triggering_delay,
                         winType,
                         pardegree,
                         name,
                         closing_func,
                         true,
                         opt_level); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Win_Farm operator
     *  
     *  \return a pointer to the created Win_Farm operator (to be explicitly deallocated/destroyed)
     */ 
    winfarm_t *build_ptr()
    {
        return new winfarm_t(input,
                             win_len,
                             slide_len,
                             triggering_delay,
                             winType,
                             pardegree,
                             name,
                             closing_func,
                             true,
                             opt_level);
    }

    /** 
     *  \brief Method to create the Win_Farm operator
     *  
     *  \return a unique_ptr to the created Win_Farm operator
     */ 
    std::unique_ptr<winfarm_t> build_unique()
    {
        return std::make_unique<winfarm_t>(input,
                                           win_len,
                                           slide_len,
                                           triggering_delay,
                                           winType,
                                           pardegree,
                                           name,
                                           closing_func,
                                           true,
                                           opt_level);
    }
};

/** 
 *  \class KeyFarm_Builder
 *  
 *  \brief Builder of the Key_Farm operator
 *  
 *  Builder class to ease the creation of the Key_Farm operator.
 */ 
template<typename T>
class KeyFarm_Builder
{
private:
    T &input;
    // extract the type of the operator to be generated by this builder (with static checks)
    using keyfarm_t = std::remove_reference_t<decltype(*get_KF_nested_type(input))>;
    // static assert to check the signature
    static_assert(!std::is_same<keyfarm_t, std::false_type>::value,
        "WindFlow Compilation Error - unknown signature passed to the KeyFarm_Builder:\n"
        "  Candidate 1 : void(uint64_t, const Iterable<tuple_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<tuple_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const tuple_t &, result_t &, RuntimeContext &)\n"
        "  Candidate 5 : a valid Pane_Farm operator\n"
        "  Candidate 6 : a valid Win_MapReduce operator\n");
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    size_t pardegree = 1;
    std::string name = "kf";
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };
    opt_level_t opt_level = opt_level_t::LEVEL2;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

    // window parameters initialization (input is a Pane_Farm)
    template<typename ...Args>
    void initWindowConf(Pane_Farm<Args...> &_pf)
    {
        win_len = _pf.win_len;
        slide_len = _pf.slide_len;
        triggering_delay = _pf.triggering_delay;
        winType = _pf.winType;
    }

    // window parameters initialization (input is a Win_MapReduce)
    template<typename ...Args>
    void initWindowConf(Win_MapReduce<Args...> &_wmr)
    {
        win_len = _wmr.win_len;
        slide_len = _wmr.slide_len;
        triggering_delay = _wmr.triggering_delay;
        winType = _wmr.winType;
    }

    // window parameters initialization (input is a logic)
    template<typename T2>
    void initWindowConf(T2 &f)
    {
        win_len = 1;
        slide_len = 1;
        triggering_delay = 0;
        winType = win_type_t::CB;
    }

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _input can be either a non-incremental/incremental window processing logic or an
     *                already instantiated Pane_Farm or Win_MapReduce operator.
     */ 
    KeyFarm_Builder(T &_input): input(_input)
    {
        initWindowConf(input);
    }

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    KeyFarm_Builder<T> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    KeyFarm_Builder<T> &withTBWindows(std::chrono::microseconds _win_len,
                                      std::chrono::microseconds _slide_len,
                                      std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Key_Farm operator
     *  
     *  \param _pardegree number of replicas
     *  \return the object itself
     */ 
    KeyFarm_Builder<T> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Key_Farm operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    KeyFarm_Builder<T> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the optimization level to build the Key_Farm operator
     *  
     *  \param _opt_level (optimization level)
     *  \return the object itself
     */ 
    KeyFarm_Builder<T> &withOptLevel(opt_level_t _opt_level)
    {
        opt_level = _opt_level;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    KeyFarm_Builder<T> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Key_Farm):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Key_Farm operator (only C++17)
     *  
     *  \return a copy of the created Key_Farm operator
     */ 
    keyfarm_t build()
    {
        return keyfarm_t(input,
                         win_len,
                         slide_len,
                         triggering_delay,
                         winType,
                         pardegree,
                         name,
                         closing_func,
                         routing_func,
                         opt_level); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Key_Farm operator
     *  
     *  \return a pointer to the created Key_Farm operator (to be explicitly deallocated/destroyed)
     */ 
    keyfarm_t *build_ptr()
    {
        return new keyfarm_t(input,
                             win_len,
                             slide_len,
                             triggering_delay,
                             winType,
                             pardegree,
                             name,
                             closing_func,
                             routing_func,
                             opt_level);
    }

    /** 
     *  \brief Method to create the Key_Farm operator
     *  
     *  \return a unique_ptr to the created Key_Farm operator
     */ 
    std::unique_ptr<keyfarm_t> build_unique()
    {
        return std::make_unique<keyfarm_t>(input,
                                           win_len,
                                           slide_len,
                                           triggering_delay,
                                           winType,
                                           pardegree,
                                           name,
                                           closing_func,
                                           routing_func,
                                           opt_level);
    }
};

/** 
 *  \class KeyFFAT_Builder
 *  
 *  \brief Builder of the Key_FFAT operator
 *  
 *  Builder class to ease the creation of the Key_FFAT operator.
 */ 
template<typename F_t, typename G_t>
class KeyFFAT_Builder
{
private:
    F_t lift_func;
    G_t comb_func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Lift(lift_func));
    using result_t = decltype(get_result_t_Lift(lift_func));
    // static asserts to check the signatures
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the KeyFFAT_Builder (first argument, lift logic):\n"
        "  Candidate 1 : void(const tuple_t &, result_t &)\n"
        "  Candidate 2 : void(const tuple_t &, result_t &, RuntimeContext &)\n");
    using result_t2 = decltype(get_result_t_Comb(comb_func));
    static_assert(!(std::is_same<std::false_type, result_t2>::value),
        "WindFlow Compilation Error - unknown signature passed to the KeyFFAT_Builder (second argument, combine logic):\n"
        "  Candidate 1 : void(const result_t &, const result_t &, result_t &)\n"
        "  Candidate 2 : void(const result_t &, const result_t &, result_t &, RuntimeContext &)\n");
    static_assert(std::is_same<result_t, result_t2>::value,
        "WindFlow Compilation Error - type mismatch in the KeyFFAT_Builder (output type of the lift logic must be equal to the input type of the combine logic)\n");
    using keyffat_t = Key_FFAT<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    size_t pardegree = 1;
    std::string name = "kff";
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _lift_func the lift logic to translate a tuple into a result
     *  \param _comb_func the combine logic to combine two results into a result
     */ 
    KeyFFAT_Builder(F_t _lift_func, G_t _comb_func): lift_func(_lift_func), comb_func(_comb_func) {}

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    KeyFFAT_Builder<F_t, G_t> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    KeyFFAT_Builder<F_t, G_t> &withTBWindows(std::chrono::microseconds _win_len,
                                             std::chrono::microseconds _slide_len,
                                             std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Key_FFAT operator
     *  
     *  \param _pardegree number of replicas
     *  \return the object itself
     */ 
    KeyFFAT_Builder<F_t, G_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Key_FFAT operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    KeyFFAT_Builder<F_t, G_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    KeyFFAT_Builder<F_t, G_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Key_FFAT):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Key_FFAT operator (only C++17)
     *  
     *  \return a copy of the created Key_Farm operator
     */ 
    keyffat_t build()
    {
        return keyffat_t(lift_func,
                         comb_func,
                         win_len,
                         slide_len,
                         triggering_delay,
                         winType,
                         pardegree,
                         name,
                         closing_func,
                         routing_func); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Key_FFAT operator
     *  
     *  \return a pointer to the created Key_FFAT operator (to be explicitly deallocated/destroyed)
     */ 
    keyffat_t *build_ptr()
    {
        return new keyffat_t(lift_func,
                             comb_func,
                             win_len,
                             slide_len,
                             triggering_delay,
                             winType,
                             pardegree,
                             name,
                             closing_func,
                             routing_func);
    }

    /** 
     *  \brief Method to create the Key_FFAT operator
     *  
     *  \return a unique_ptr to the created Key_FFAT operator
     */ 
    std::unique_ptr<keyffat_t> build_unique()
    {
        return std::make_unique<keyffat_t>(lift_func,
                                           comb_func,
                                           win_len,
                                           slide_len,
                                           triggering_delay,
                                           winType,
                                           pardegree,
                                           name,
                                           closing_func,
                                           routing_func);
    }
};

/** 
 *  \class PaneFarm_Builder
 *  
 *  \brief Builder of the Pane_Farm operator
 *  
 *  Builder class to ease the creation of the Pane_Farm operator.
 */ 
template<typename F_t, typename G_t>
class PaneFarm_Builder
{
private:
    F_t func_F;
    G_t func_G;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Win(func_F));
    using result_t = decltype(get_result_t_Win(func_F));
    // static asserts to check the signature
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the PaneFarm_Builder (first argument, PLQ logic):\n"
        "  Candidate 1 : void(uint64_t, const Iterable<tuple_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<tuple_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const tuple_t &, result_t &, RuntimeContext &)\n");
    using result_t2 = decltype(get_result_t_Win(func_G));
    static_assert(!(std::is_same<std::false_type, result_t2>::value),
        "WindFlow Compilation Error - unknown signature passed to the PaneFarm_Builder (second argument, WLQ logic):\n"
        "  Candidate 1 : void(uint64_t, const Iterable<result_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<result_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const result_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const result_t &, result_t &, RuntimeContext &)\n");
    static_assert(std::is_same<result_t, result_t2>::value,
        "WindFlow Compilation Error - type mismatch in the PaneFarm_Builder (output type of the PLQ logic must be equal to the input type of the WLQ logic)\n");
    using panefarm_t = Pane_Farm<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    size_t plq_degree = 1;
    size_t wlq_degree = 1;
    std::string name = "pf";
    opt_level_t opt_level = opt_level_t::LEVEL0;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func_F the non-incremental/incremental pane procesing logic (PLQ)
     *  \param _func_G the non-incremental/incremental window processing logic (PLQ)
     */ 
    PaneFarm_Builder(F_t _func_F, G_t _func_G): func_F(_func_F), func_G(_func_G) {}

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &withTBWindows(std::chrono::microseconds _win_len,
                                              std::chrono::microseconds _slide_len,
                                              std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism configuration within the Pane_Farm operator
     *  
     *  \param _plq_degree number replicas in the PLQ stage
     *  \param _wlq_degree number replicas in the WLQ stage
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &withParallelism(size_t _plq_degree, size_t _wlq_degree)
    {
        plq_degree = _plq_degree;
        wlq_degree = _wlq_degree;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Pane_Farm operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the optimization level to build the Pane_Farm operator
     *  
     *  \param _opt_level (optimization level)
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &withOptLevel(opt_level_t _opt_level)
    {
        opt_level = _opt_level;
        return *this;
    }

    /** 
     *  \brief Method to prepare the operator for Nesting with Key_Farm or Win_Farm
     *  
     *  \return the object itself
     */ 
    PaneFarm_Builder<F_t, G_t> &prepare4Nesting()
    {
        opt_level = opt_level_t::LEVEL2;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    PaneFarm_Builder<F_t, G_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Pane_Farm):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Pane_Farm operator (only C++17)
     *  
     *  \return a copy of the created Pane_Farm operator
     */ 
    panefarm_t build()
    {
        return panefarm_t(func_F,
                          func_G,
                          win_len,
                          slide_len,
                          triggering_delay,
                          winType,
                          plq_degree,
                          wlq_degree,
                          name,
                          closing_func,
                          true,
                          opt_level); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Pane_Farm operator
     *  
     *  \return a pointer to the created Pane_Farm operator (to be explicitly deallocated/destroyed)
     */ 
    panefarm_t *build_ptr()
    {
        return new panefarm_t(func_F,
                              func_G,
                              win_len,
                              slide_len,
                              triggering_delay,
                              winType,
                              plq_degree,
                              wlq_degree,
                              name,
                              closing_func,
                              true,
                              opt_level);
    }

    /** 
     *  \brief Method to create the Pane_Farm operator
     *  
     *  \return a unique_ptr to the created Pane_Farm operator
     */ 
    std::unique_ptr<panefarm_t> build_unique()
    {
        return std::make_unique<panefarm_t>(func_F,
                                            func_G,
                                            win_len,
                                            slide_len,
                                            triggering_delay,
                                            winType,
                                            plq_degree,
                                            wlq_degree,
                                            name,
                                            closing_func,
                                            true,
                                            opt_level);
    }
};

/** 
 *  \class WinMapReduce_Builder
 *  
 *  \brief Builder of the Win_MapReduce operator
 *  
 *  Builder class to ease the creation of the Win_MapReduce operator.
 */ 
template<typename F_t, typename G_t>
class WinMapReduce_Builder
{
private:
    F_t func_F;
    G_t func_G;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Win(func_F));
    using result_t = decltype(get_result_t_Win(func_F));
    // static asserts to check the signature
     static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the WinMapReduce_Builder (first argument, MAP logic):\n"
        "  Candidate 1 : void(uint64_t, const Iterable<tuple_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<tuple_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const tuple_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const tuple_t &, result_t &, RuntimeContext &)\n");
    using result_t2 = decltype(get_result_t_Win(func_G));
    static_assert(!(std::is_same<tuple_t, std::false_type>::value || std::is_same<result_t, std::false_type>::value),
        "WindFlow Compilation Error - unknown signature passed to the WinMapReduce_Builder (second argument, REDUCE logic):\n"
        "  Candidate 1 : void(uint64_t, const Iterable<result_t> &, result_t &)\n"
        "  Candidate 2 : void(uint64_t, const Iterable<result_t> &, result_t &, RuntimeContext &)\n"
        "  Candidate 3 : void(uint64_t, const result_t &, result_t &)\n"
        "  Candidate 4 : void(uint64_t, const result_t &, result_t &, RuntimeContext &)\n");
    static_assert(std::is_same<result_t, result_t2>::value,
        "WindFlow Compilation Error - type mismatch in the WinMapReduce_Builder (output type of the MAP logic must be equal to the input type of the REDUCE logic)\n");
    using winmapreduce_t = Win_MapReduce<tuple_t, result_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    uint64_t win_len = 1;
    uint64_t slide_len = 1;
    uint64_t triggering_delay = 0;
    win_type_t winType = win_type_t::CB;
    size_t map_degree = 2;
    size_t reduce_degree = 1;
    std::string name = "wmr";
    opt_level_t opt_level = opt_level_t::LEVEL0;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func_F the non-incremental/incremental window map logic (MAP)
     *  \param _func_G the non-incremental/incremental window reduce logic (REDUCE)
     */ 
    WinMapReduce_Builder(F_t _func_F, G_t _func_G): func_F(_func_F), func_G(_func_G) {}

    /** 
     *  \brief Method to specify the configuration for count-based windows
     *  
     *  \param _win_len window length (in no. of tuples)
     *  \param _slide_len slide length (in no. of tuples)
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &withCBWindows(uint64_t _win_len, uint64_t _slide_len)
    {
        win_len = _win_len;
        slide_len = _slide_len;
        winType = win_type_t::CB;
        return *this;
    }

    /** 
     *  \brief Method to specify the configuration for time-based windows
     *  
     *  \param _win_len window length (in microseconds)
     *  \param _slide_len slide length (in microseconds)
     *  \param _triggering_delay (in microseconds)
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &withTBWindows(std::chrono::microseconds _win_len,
                                                  std::chrono::microseconds _slide_len,
                                                  std::chrono::microseconds _triggering_delay=std::chrono::microseconds::zero())
    {
        win_len = _win_len.count();
        slide_len = _slide_len.count();
        triggering_delay = _triggering_delay.count();
        winType = win_type_t::TB;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism configuration within the Win_MapReduce operator
     *  
     *  \param _map_degree number of replicas in the MAP stage
     *  \param _reduce_degree number of replicas in the REDUCE stage
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &withParallelism(size_t _map_degree, size_t _reduce_degree)
    {
        map_degree = _map_degree;
        reduce_degree = _reduce_degree;
        return *this;
    }

    /** 
     *  \brief Method to specify the name of the Win_MapReduce operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the optimization level to build the Win_MapReduce operator
     *  
     *  \param _opt_level (optimization level)
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &withOptLevel(opt_level_t _opt_level)
    {
        opt_level = _opt_level;
        return *this;
    }

    /** 
     *  \brief Method to prepare the operator for Nesting with Key_Farm or Win_Farm
     *  
     *  \return the object itself
     */ 
    WinMapReduce_Builder<F_t, G_t> &prepare4Nesting()
    {
        opt_level = opt_level_t::LEVEL2;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    WinMapReduce_Builder<F_t, G_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Win_MapReduce):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Win_MapReduce operator (only C++17)
     *  
     *  \return a copy of the created Win_MapReduce operator
     */ 
    winmapreduce_t build()
    {
        return winmapreduce_t(func_F,
                              func_G,
                              win_len,
                              slide_len,
                              triggering_delay,
                              winType,
                              map_degree,
                              reduce_degree,
                              name,
                              closing_func,
                              true,
                              opt_level); // guaranteed copy elision in C++17
    }
#endif

    /** 
     *  \brief Method to create the Win_MapReduce operator
     *  
     *  \return a pointer to the created Win_MapReduce operator (to be explicitly deallocated/destroyed)
     */ 
    winmapreduce_t *build_ptr()
    {
        return new winmapreduce_t(func_F,
                                  func_G,
                                  win_len,
                                  slide_len,
                                  triggering_delay,
                                  winType,
                                  map_degree,
                                  reduce_degree,
                                  name,
                                  closing_func,
                                  true,
                                  opt_level);
    }

    /** 
     *  \brief Method to create the Win_MapReduce operator
     *  
     *  \return a unique_ptr to the created Win_MapReduce operator
     */ 
    std::unique_ptr<winmapreduce_t> build_unique()
    {
        return std::make_unique<winmapreduce_t>(func_F,
                                                func_G,
                                                win_len,
                                                slide_len,
                                                triggering_delay,
                                                winType,
                                                map_degree,
                                                reduce_degree,
                                                name,
                                                closing_func,
                                                true,
                                                opt_level);
    }
};

/** 
 *  \class Sink_Builder
 *  
 *  \brief Builder of the Sink operator
 *  
 *  Builder class to ease the creation of the Sink operator.
 */ 
template<typename F_t>
class Sink_Builder
{
private:
    F_t func;
    // extract the type of the operator to be generated by this builder (with static checks)
    using tuple_t = decltype(get_tuple_t_Sink(func));
    // static assert to check the signature
    static_assert(!std::is_same<tuple_t, std::false_type>::value,
        "WindFlow Compilation Error - unknown signature passed to the Sink_Builder:\n"
        "  Candidate 1 : void(std::optional<tuple_t> &)\n"
        "  Candidate 2 : void(std::optional<tuple_t> &, RuntimeContext &)\n"
        "  Candidate 3 : void(std::optional<std::reference_wrapper<tuple_t>>)\n"
        "  Candidate 4 : void(std::optional<std::reference_wrapper<tuple_t>>, RuntimeContext &)\n");
    using sink_t = Sink<tuple_t>;
    // type of the closing function
    using closing_func_t = std::function<void(RuntimeContext&)>;
    // type of the function to map the key hashcode onto an identifier starting from zero to pardegree-1
    using routing_func_t = std::function<size_t(size_t, size_t)>;
    uint64_t pardegree = 1;
    std::string name = "sink";
    bool isKeyBy = false;
    closing_func_t closing_func = [](RuntimeContext &r) -> void { return; };
    routing_func_t routing_func = [](size_t k, size_t n) { return k%n; };

public:
    /** 
     *  \brief Constructor
     *  
     *  \param _func logic to absorb the stream elements
     */ 
    Sink_Builder(F_t _func): func(_func) {}

    /** 
     *  \brief Method to specify the name of the Sink operator
     *  
     *  \param _name string with the name to be given
     *  \return the object itself
     */ 
    Sink_Builder<F_t> &withName(std::string _name)
    {
        name = _name;
        return *this;
    }

    /** 
     *  \brief Method to specify the parallelism of the Sink operator
     *  
     *  \param _pardegree number of sink replicas
     *  \return the object itself
     */ 
    Sink_Builder<F_t> &withParallelism(size_t _pardegree)
    {
        pardegree = _pardegree;
        return *this;
    }

    /** 
     *  \brief Method to enable the key-based routing
     *  
     *  \return the object itself
     */ 
    Sink_Builder<F_t> &enable_KeyBy()
    {
        isKeyBy = true;
        return *this;
    }

    /** 
     *  \brief Method to specify the closing logic used by the operator
     *  
     *  \param _closing_func closing logic to be used by the operator
     *  \return the object itself
     */ 
    template<typename closing_F_t>
    Sink_Builder<F_t> &withClosingFunction(closing_F_t _closing_func)
    {
        // static assert to check the signature
        static_assert(!std::is_same<decltype(check_closing_t(_closing_func)), std::false_type>::value,
            "WindFlow Compilation Error - unknown signature passed to withClosingFunction (of a Sink):\n"
            "  Candidate : void(RuntimeContext &)\n");
        closing_func = _closing_func;
        return *this;
    }

#if __cplusplus >= 201703L
    /** 
     *  \brief Method to create the Sink operator (only C++17)
     *  
     *  \return a copy of the created Sink operator
     */ 
    sink_t build()
    {
        if (!isKeyBy) {
            return sink_t(func,
                          pardegree,
                          name,
                          closing_func); // guaranteed copy elision in C++17
        }
        else {
            return sink_t(func,
                          pardegree,
                          name,
                          closing_func,
                          routing_func); // guaranteed copy elision in C++17
        }
    }
#endif

    /** 
     *  \brief Method to create the Sink operator
     *  
     *  \return a pointer to the created Sink operator (to be explicitly deallocated/destroyed)
     */ 
    sink_t *build_ptr()
    {
        if (!isKeyBy) {
            return new sink_t(func,
                              pardegree,
                              name,
                              closing_func);
        }
        else {
            return new sink_t(func,
                              pardegree,
                              name,
                              closing_func,
                              routing_func);
        }
    }

    /** 
     *  \brief Method to create the Sink operator
     *  
     *  \return a unique_ptr to the created Sink operator
     */ 
    std::unique_ptr<sink_t> build_unique()
    {
        if (!isKeyBy) {
            return std::make_unique<sink_t>(func,
                                            pardegree,
                                            name,
                                            closing_func);
        }
        else {
            return std::make_unique<sink_t>(func,
                                            pardegree,
                                            name,
                                            closing_func,
                                            routing_func);
        }
    }
};

} // namespace wf

#endif
